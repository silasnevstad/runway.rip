---
title: "Supabase Tables for Profiles & Leads"
description: "Learn how to create and configure the Profiles and Leads tables in Supabase for authentication, subscription handling, and waitlist signups."
onThisPage:
  - title: "Profiles Table Setup"
    href: "#profiles-table-setup"
  - title: "Leads Table Setup"
    href: "#leads-table-setup"
  - title: "Row Level Security (RLS)"
    href: "#row-level-security"
  - title: "Next Steps"
    href: "#next-steps"
related:
  - title: "Authentication"
    href: "/docs/features/auth"
sites:
  - title: "Supabase"
    href: "https://supabase.com"
---

# Supabase Tables for Profiles & Leads

In this guide, you'll learn how to set up two essential tables in your Supabase database:

- **Profiles** – Used to extend the authenticated user with additional data such as subscription details, customer IDs, and access flags.
- **Leads** – Used to capture email addresses from users joining your waitlist or mailing list.

Follow the steps below to create these tables and apply security best practices using Row Level Security (RLS).

<br />
<div id="profiles-table-setup" />

## Profiles Table Setup

The **profiles** table stores additional information about your authenticated users. This is particularly useful for handling subscriptions and other user-specific metadata.

```sql
-- Create the profiles table in the public schema.
CREATE TABLE public.profiles (
id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
name TEXT,
email TEXT,
image TEXT,
customer_id TEXT,
price_id TEXT,
subscription_id TEXT,
subscription_status TEXT,
has_access BOOLEAN DEFAULT false,
created_at TIMESTAMPTZ DEFAULT (now() AT TIME ZONE 'UTC'),
updated_at TIMESTAMPTZ DEFAULT (now() AT TIME ZONE 'UTC')
);
```

Next, create a function and trigger to automatically update the `updated_at` timestamp on any changes:

```sql
-- Create a function to update the updated_at column.
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
NEW.updated_at = (now() AT TIME ZONE 'UTC');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

```sql
-- Create a trigger that invokes the function before each update.
CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

Optionally, if you want to automatically add a profile when a new user signs up, create the following function and trigger:

```sql
-- Create a function to automatically add a new profile on user signup.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
INSERT INTO public.profiles (id, email, name, image, created_at, updated_at)
VALUES (
NEW.id,
NEW.email,
COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
NEW.raw_user_meta_data->>'avatar_url',
(now() AT TIME ZONE 'UTC'),
(now() AT TIME ZONE 'UTC')
);
RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

```sql
-- Create a trigger on auth.users to invoke the above function after a new user is inserted.
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

<br />
<div id="leads-table-setup" />

## Leads Table Setup

The **leads** table is designed to capture email addresses for your waitlist or mailing list. This table is intentionally open for insertions—even from unauthenticated users.

```sql
-- Create the leads table to store waitlist signups.
CREATE TABLE public.leads (
id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
email TEXT NOT NULL,
created_at TIMESTAMPTZ DEFAULT timezone('utc', now()) NOT NULL
);
```

Enable Row Level Security on the leads table:

```sql
-- Enable RLS for the leads table.
ALTER TABLE public.leads ENABLE ROW LEVEL SECURITY;
```

Finally, create a policy that allows anyone to insert their email into the leads table:

```sql
-- Create a policy to allow public insertions into leads.
CREATE POLICY insert_lead ON public.leads
FOR INSERT
TO public
WITH CHECK (true);
```

<br />
<div id="row-level-security" />

## Row Level Security (RLS)

For security, ensure that RLS is enabled and properly configured on both tables. The profiles table policies below ensure that users can only read, update, insert, or delete their own profiles.

```sql
-- Enable RLS for the profiles table.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to read their own profile.
CREATE POLICY read_own_profile_data ON public.profiles
FOR SELECT
USING (auth.uid() = id);

-- Policy: Allow users to update their own profile.
CREATE POLICY update_own_profile_data ON public.profiles
FOR UPDATE
USING (auth.uid() = id);

-- Policy: Allow users to insert their own profile.
CREATE POLICY insert_own_profile_data ON public.profiles
FOR INSERT
WITH CHECK (auth.uid() = id);

-- Policy: Allow users to delete their own profile.
CREATE POLICY delete_own_profile_data ON public.profiles
FOR DELETE
USING (auth.uid() = id);
```

<Tip>
    Enabling RLS and setting up precise policies is crucial for protecting your users’ data. Review your policies regularly to ensure they meet your security requirements.
</Tip>

<br />
<div id="next-steps" />

## Next Steps

Once you’ve created these tables and applied the necessary security policies, your Supabase database is ready to support both extended user profiles and a public mailing list for waitlist signups. You can now:

- Integrate these tables with your authentication flows.
- Use your existing subscription handlers (like those in `libs/stripe/subscriptionHandlers.js`) to update profile data.
- Build front-end components (e.g., waitlist forms) that interact directly with these tables via the Supabase client.

By following these steps, you ensure a secure and robust setup for managing user data and leads—giving you a strong foundation for your project.

Happy coding!
